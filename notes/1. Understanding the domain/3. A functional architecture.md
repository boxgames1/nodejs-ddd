- Using C4 terminology, define boundaries between containers, components and modules to decrease the cost in case of changes.
- It's a good practice to build the system as a monolith at the beginning and refactor to decoupled containers as you need. Starting with a microservices architecture is an overkill and will pay the *Microservice Premium*, unless 100% sure of the benefits.
- Using events as the only way of communication between BCs is crucial to keep autonomy and decoupling.
- Domain Object is designed for use only **inside the context**
- Data Transfer Object *DTO* is the object in charge of serialize the data transmitted **between contexts**.
- Add validation gates in the BC to input/output as data from the exterior is untrustable.
- Contracts between BCs:
  -  Shared kernel relationship
  -  Consumer driven contract relationship
  -  Conformist relationship
  -  Anti Corruption Layer *ACL* (usually for communications with 3rd parties)
-  In the event, send only the info that de downstream BC needs.
-  Avoid domain events within a BC
-  The traditional "layered approach" to structure the code has many problems, it breaks the principle *Code that changes together, belongs together*
-  A better approach is the "vertical" slices, where each workflow contains all the code it needs to get the job done:
   -  API/Interface
   -  Services layer
   -  Domain
   -  Database
-  *Onion architecture* says that "all dependencies must point inward", so each layer can only depend on inner layers, not on layers further out. This is similar to Hexagonal architecture and Clean architecture. To ensure that **all dependencies point inward** we will use the functional equivalent to dependency injection, **composing a pipeline**.
-  Keep I/O and database access at the edges. It combines very nicely with the *persistence ignorance* concept.
-  Keep functions predictables, immutables. 
-  Avoid "impure" functions in the core domain