- The goal is to create a BC that any data inside is trustable while data coming from outside is untrastable.
- **Integrity** means that a piece of data folowws the correct business rules.
- **Consistency** means that different parts of the domain model agree about facts. Depends on the context.
- **Constrained types** are those that apart of the type have rules. With them you dont need to do defensive coding.
-  **Smart constructor** is the one that checks the validity in the creation.
-  Units of measure can be used as well to avoid the mixing.
-  An **invariant** is a condition that stays **true** no matter what else happens.
-  Use TS **private constructors** to allow the creation only from inside the service.
-  Try to capture business rules in the type system and *Make illegal states unrepresentable*. Doing this properly there wont be invalid situations in code that not need unit thest. Instead, there will be *compile-time* unit tests, as the type system will warn.
-  Create types for different variants of a type instead of having one with choices if it clears the model.
-  Make updates at the top-level component to ensure consistency in the low-level.
-  If a change is persisted in DB, the related components must be changed and persisted as well.
-  Messagging/sending events is the way of communication with other contexts. To check if it fails there are 3 ways to do:
   -  Do nothing. If costs are small. No consistency.
   -  Detect that message was lost and re-send. **Reconciliation system**. Eventual consistency.
   -  **Compensation action** that *undoes* the the previous action and fixes the error. It has to be justified, based on context. Consistency.
-  Only update one aggregate per transaction. If more than one is involved, use eventual consistency and messages even with both aggregates within the same BC.
-  Dont reuse aggregates if it doesnt make sense to do so.
-  Shared validation functions can be used accross different aggregates.