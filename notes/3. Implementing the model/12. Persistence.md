- Use CQRS when you want to separate the objects that you use for reading ar writing, so they can grow independently.
- Queries --> read model
- Commands --> write model
- It cam also be used on DBs, having one for write and one for read. Or tables for writing and views for reading
- In event sourcing the current state is not represented in a single object. Insteead, evey time there is a change to the state, an event representing the change is persisted.
- It works like a Version Control System.
- Bounded contexts must own their data storage
- A BC can change his storage without having to coordinate with other BCs
- No other system can directly access the date owned by the BC. Just by API
- Relational DBs work better with FP approach. Set-oriented operations (SELECT, WHERE) in a database are smilar to the list-oriented operations (map, filter) in fp languages
- To map choice types to tables there are two options:
  - All cases in one table. (Easier. Not null fields)
  - Each case has its own table. (More complexity, better constraints)
- To map nested types to tables:
  - If the inner type is a DDD value object, without his own identity, it should be stored "inline" with the parent data
  - If the inner type is a DDD entity, with his own identity, it should be stored in a separate table.
- To read from DB, and convert back the DB data to complex types, we will have `toDomain` functions that will de-serialize the data.
- One aggregate - One transaction
- To avoid overcost, and assuming that most times, things go well, don't use two-phase commit, just use reconcilliation process to detect inconsistency and compensating transactions to rollback a DB update.
- Always keep I/O at the edges
